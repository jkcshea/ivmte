% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mst.R
\name{gentarget}
\alias{gentarget}
\title{Generating LP moments for IV-like estimands}
\usage{
gentarget(treat, m0, m1, uname, target, target.weight0, target.weight1,
  target.knots0, target.knots1, late.Z, late.from, late.to, late.X, eval.X,
  genlate.lb, genlate.ub, data, splinesobj, pmodobj, pm0, pm1,
  point = FALSE, noisy = TRUE)
}
\arguments{
\item{treat}{variable name for treatment indicator}

\item{m0}{one-sided formula for marginal treatment response
function for control group. Splines can also be incorporated
using the expression "uSplines(degree, knots, intercept)". The
'intercept' argument may be omitted, and is set to \code{TRUE}
by default.}

\item{m1}{one-sided formula for marginal treatment response
function for treated group. Splines can also be incorporated
using the expression "uSplines(degree, knots, intercept)". The
'intercept' argument may be omitted, and is set to \code{TRUE}
by default.}

\item{uname}{variable name for unobservable used in declaring MTRs}

\item{target}{target parameter to be estimated. Currently function
allows for ATE ("\code{ate}"), ATT ("\code{att}"), ATU
("\code{atu}"), LATE ("\code{late}"), and generalized LATE
("\code{genlate}").}

\item{target.weight0}{user-defined weight function for the control
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
\code{data}. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.}

\item{target.weight1}{user-defined weight function for the treated
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
\code{data}. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.}

\item{target.knots0}{user-defined set of functions defining the
knots associated with splines weights for the control
group. The arguments of the function should consist only of
variable names in \code{data}. If the knot is constant across
all observations, then the user can instead submit the value of
the weight instead of a function.}

\item{target.knots1}{user-defined set of functions defining the
knots associated with splines weights for the treated
group. The arguments of the function should be variable names
in \code{data}. If the knot is constant across all
observations, then the user can instead submit the value of the
weight instead of a function.}

\item{late.Z}{vector of variable names used to define the LATE.}

\item{late.from}{baseline set of values of Z used to define the
LATE.}

\item{late.to}{comparison set of values of Z used to define the
LATE.}

\item{late.X}{vector of variable names of covariates which we
condition on when defining the LATE.}

\item{eval.X}{numeric vector of the values at which we condition
variables in \code{late.X} on when estimating the LATE.}

\item{genlate.lb}{lower bound value of unobservable u for
estimating generalized LATE.}

\item{genlate.ub}{upper bound value of unobservable u for
estimating generalized LATE.}

\item{data}{\code{data.frame} used to estimate the treatment
effects.}

\item{splinesobj}{list of spline components in the MTRs for treated
and control groups. Spline terms are extracted using
\code{\link{removeSplines}}.}

\item{pmodobj}{A vector of propensity scores.}

\item{pm0}{A list of the monomials in the MTR for d = 0.}

\item{pm1}{A list of the monomials in the MTR for d = 1.}

\item{point}{boolean, set to \code{FALSE} by default. \code{point}
refers to whether the partial or point identification is
desired. If set to \code{FALSE}, then the gamma moments are
returned, i.e. sample averages are taken. If set to
\code{TRUE}, then no sample averages are taken, and a matrix is
returned. The sample average of each column of the matrix
corresponds to a particular gamma moment.}

\item{noisy}{boolean, default set to \code{TRUE}. If \code{TRUE},
then messages are provided throughout the estimation
procedure. Set to \code{FALSE} to suppress all messages,
e.g. when performing the bootstrap.}
}
\value{
A list containing either the vectors of gamma moments for
    \code{D = 0} and \code{D = 1}, or a matrix of individual gamma
    values for \code{D = 0} and \code{D = 1}. Additoinally, two
    vectors are returned. \code{xindex0} and \code{xindex1} list
    the variables that interact with the unobservable \code{u} in
    \code{m0} and \code{m1}. \code{uexporder0} and
    \code{uexporder1} lists the exponents of the unobservable
    \code{u} in each term it appears in.
}
\description{
This function takes in the IV estimate and its IV-like
specification, and generates a list containing the corresponding
point estimate, and the corresponding moments (gammas) that will
enter into the constraint matrix of the LP problem.
}
\examples{
## Declare MTR functions
formula1 = ~ 1 + u
formula0 = ~ 1 + u
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Declare propensity score model
propensityObj <- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Construct MTR polynomials
polynomials0 <- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

polynomials1 <- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

## Generate target gamma moments
gentarget(treat = "d",
          m0 = ~ 1 + u,
          m1 = ~ 1 + u,
          uname = u,
          target = "atu",
          data = dtm,
          splinesobj = splinesList,
          pmodobj = propensityObj,
          pm0 = polynomials0,
          pm1 = polynomials1,
          point = FALSE)


}
